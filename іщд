8.


def studying_hours(a):
    max_length = 1
    current_length = 1
    for i in range(1, len(a)):
        if a[i] >= a[i-1]:
            current_length += 1
        else:
            current_length = 1

        if current_length > max_length:
            max_length = current_length
    return max_length


7.


def Cipher_Zeroes(N):
    visible_zeros = {"0": 1, "6": 1, "8": 2, "9": 1}
    amount_of_nulls = 0

    for num in N:
        if num in visible_zeros:
            amount_of_nulls += visible_zeros[num]

    if (amount_of_nulls % 2) == 0 and amount_of_nulls > 0:
        amount_of_nulls -= 1
    elif (amount_of_nulls % 2) != 0 and amount_of_nulls > 0:
        amount_of_nulls += 1
    else:
        pass

    return format(amount_of_nulls, 'b')


6.


def order(a):
    for x in a:
        if x > a[-1]:
            return "descending"
        elif x < a[-1]:
            return "ascending"
        else:
            return "not sorted"


5.


def toPostFixExpression(expression):
    operators = {
        '%': 4,
        '/': 3,
        '*': 2,
        '+': 1,
        '-': 0,
    }
    result = []
    found_operators = []
    # stack = []

    for element in expression:

        if element not in operators and element != '(' and element != ')':
            result.append(element)

        elif element in operators:
            while found_operators and found_operators[-1] != '(' and operators[found_operators[-1]] >= operators[element]:
                result.append(found_operators.pop())
            found_operators.append(element)

        elif element == '(':
            found_operators.append(element)

        elif element == ')':
            while found_operators[-1] != '(':
                result.append(found_operators.pop())
            found_operators.pop()

    while found_operators:
        result.append(found_operators.pop())

    return result


4.


def findPermutation(p, q):
    result = []

    for e in q:
        result.append(p.index(e) + 1)
    return result


print(findPermutation(p=[5, 1, 3],  q=[3, 1, 5]))


3.


def isPalindrome(str):
    occur = {}
    for letter in str:
        if letter in occur:
            occur[letter] += 1
        else:
            occur[letter] = 1

        # if char == str[-i]:
        #     continue
        # else:
        #     return False

    odd_letter_count = 0
    for letter in occur.values():
        if letter % 2 != 0:
            odd_letter_count += 1

    return odd_letter_count <= 1


2.


def filterBible(scripts, book_id, chapter_id):
    founded_scripts = []
    for script in scripts:
        if script[:2] == book_id:
            if script[2:5] == chapter_id:
                founded_scripts.append(script)
    return founded_scripts


1.


def kthTerm(n, k):
    values = []
    for i in range(k):
        values.append(n ** i)
        for j in values[:-1]:
            if len(values) >= k:
                return values[k - 1]
            values.append((n ** i) + j)
    return values[k - 1]
